---
layout: null
title: "霓虹贪吃蛇"
permalink: /games/snake/
---
<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>霓虹贪吃蛇：双人对战版</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');

    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background-color: #050505;
      font-family: 'Orbitron', sans-serif;
      user-select: none;
    }

    #hud {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      padding: 20px 40px;
      box-sizing: border-box;
      display: flex;
      justify-content: space-between;
      align-items: center;
      z-index: 10;
      pointer-events: none;
    }

    .score-box {
      font-size: 20px;
      font-weight: bold;
      text-shadow: 0 0 10px currentColor;
    }

    #p1-score { color: #00ffff; }
    #p2-score { color: #ff00ff; }

    #menu-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.85);
      backdrop-filter: blur(5px);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 20;
      transition: opacity 0.3s;
    }

    h1 {
      color: #fff;
      font-size: 4rem;
      margin: 0;
      text-shadow: 2px 2px 0px #00ffff, -2px -2px 0px #ff00ff;
      letter-spacing: 5px;
      text-transform: uppercase;
    }

    .controls-info {
      display: flex;
      gap: 50px;
      margin: 40px 0;
      color: #ccc;
    }

    .control-block {
      text-align: center;
      border: 1px solid rgba(255,255,255,0.1);
      padding: 20px;
      border-radius: 10px;
      background: rgba(255,255,255,0.05);
    }

    .key-icon {
      display: inline-block;
      border: 1px solid #fff;
      padding: 5px 10px;
      border-radius: 5px;
      margin: 2px;
      font-size: 0.8rem;
      min-width: 20px;
    }

    button {
      background: transparent;
      color: #fff;
      font-family: 'Orbitron', sans-serif;
      font-size: 1.5rem;
      padding: 15px 50px;
      border: 2px solid #fff;
      border-radius: 50px;
      cursor: pointer;
      transition: 0.2s;
      text-transform: uppercase;
      pointer-events: auto;
    }

    button:hover {
      background: #fff;
      color: #000;
      box-shadow: 0 0 30px rgba(255, 255, 255, 0.5);
    }

    .hidden { opacity: 0; pointer-events: none; }

    #winner-text {
      font-size: 2rem;
      margin-bottom: 20px;
      display: none;
    }
  </style>
</head>
<body>

  <div id="hud">
    <div class="score-box" id="p1-score">P1 (Cyan): 0</div>
    <button style="font-size:12px; padding:5px 15px; border:1px solid #555;" onclick="resetGame()">RESTART</button>
    <div class="score-box" id="p2-score">P2 (Magenta): 0</div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <div id="menu-layer">
    <h1>Neon Battle</h1>
    <div id="winner-text">PLAYER 1 WINS!</div>

    <div class="controls-info">
      <div class="control-block" style="color:#00ffff; text-shadow:0 0 10px rgba(0,255,255,0.5);">
        <h3>PLAYER 1</h3>
        <div><span class="key-icon">↑</span><span class="key-icon">↓</span><span class="key-icon">←</span><span class="key-icon">→</span></div>
      </div>
      <div class="control-block" style="color:#ff00ff; text-shadow:0 0 10px rgba(255,0,255,0.5);">
        <h3>PLAYER 2</h3>
        <div><span class="key-icon">W</span><span class="key-icon">A</span><span class="key-icon">S</span><span class="key-icon">D</span></div>
      </div>
    </div>

    <button onclick="startGame()">START BATTLE</button>
  </div>

  <script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const menuLayer = document.getElementById('menu-layer');
    const winnerText = document.getElementById('winner-text');
    const p1ScoreEl = document.getElementById('p1-score');
    const p2ScoreEl = document.getElementById('p2-score');

    const gridSize = 20;
    let tileX, tileY;
    let gameInterval;
    let isRunning = false;

    // ========= 调参区域 =========
    const MAP_CFG = {
      INITIAL_OBS_RATIO: 0.010,
      OBSTACLE_MIN: 10,
      OBSTACLE_MAX: 90,

      CLUSTER_MIN_SIZE: 4,
      CLUSTER_MAX_SIZE: 14,
      CLUSTER_WALK_FACTOR: 3,

      SAFE_RADIUS_SPAWN: 5,
      SAFE_RADIUS_DYNAMIC: 4,
      BORDER_MARGIN: 2,

      CONNECT_COVERAGE_MIN: 0.62,
      MAX_GEN_ATTEMPTS: 40,

      PORTAL_PAIRS: 2,
      INIT_FOOD_COUNT: 3,

      SCORE_STEP: 8,
      ADD_CLUSTER_MIN: 2,
      ADD_CLUSTER_MAX: 6,
      MAX_TOTAL_OBS: 140
    };

    let players = [];
    let foods = [];
    let obstacles = [];
    let portals = [];

    let difficultyLevel = 0;

    // ---------- utils ----------
    const keyOf = (x, y) => `${x},${y}`;
    const randInt = (min, maxExclusive) => Math.floor(Math.random() * (maxExclusive - min) + min);
    const dirs4 = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];

    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      tileX = Math.floor(canvas.width / gridSize);
      tileY = Math.floor(canvas.height / gridSize);
    }
    window.addEventListener('resize', resize);
    resize();

    function isInsideMargin(x, y) {
      const m = MAP_CFG.BORDER_MARGIN;
      return x >= m && x < (tileX - m) && y >= m && y < (tileY - m);
    }

    function inSafeZone(x, y, centers, radius) {
      for (const c of centers) {
        if (Math.max(Math.abs(x - c.x), Math.abs(y - c.y)) <= radius) return true;
      }
      return false;
    }

    function buildOccupiedSet({ includeFoods = true } = {}) {
      const occ = new Set();
      for (const s of players) for (const part of s.body) occ.add(keyOf(part.x, part.y));
      for (const o of obstacles) occ.add(keyOf(o.x, o.y));
      for (const p of portals) {
        occ.add(keyOf(p.a.x, p.a.y));
        occ.add(keyOf(p.b.x, p.b.y));
      }
      if (includeFoods) for (const f of foods) occ.add(keyOf(f.x, f.y));
      return occ;
    }

    function randomEmptyCell({ occ, forbidCenters = [], forbidRadius = 0, maxTry = 3000 } = {}) {
      for (let t = 0; t < maxTry; t++) {
        const x = randInt(0, tileX);
        const y = randInt(0, tileY);
        if (!isInsideMargin(x, y)) continue;
        if (forbidRadius > 0 && inSafeZone(x, y, forbidCenters, forbidRadius)) continue;
        if (occ.has(keyOf(x, y))) continue;
        return { x, y };
      }
      return null;
    }

    // ---------- connectivity ----------
    function portalLinkMap() {
      const map = new Map();
      for (const p of portals) {
        map.set(keyOf(p.a.x, p.a.y), {x: p.b.x, y: p.b.y});
        map.set(keyOf(p.b.x, p.b.y), {x: p.a.x, y: p.a.y});
      }
      return map;
    }

    function validateConnectivity({ obstacleSet, startA, startB } = {}) {
      if (obstacleSet.has(keyOf(startA.x, startA.y))) return false;
      if (obstacleSet.has(keyOf(startB.x, startB.y))) return false;

      const portalMap = portalLinkMap();
      const visited = new Set();

      const q = [];
      let qi = 0;
      q.push(startA);
      visited.add(keyOf(startA.x, startA.y));

      const totalCells = tileX * tileY;
      const freeCells = totalCells - obstacleSet.size;
      if (freeCells <= 0) return false;

      while (qi < q.length) {
        const cur = q[qi++];
        const ck = keyOf(cur.x, cur.y);

        const link = portalMap.get(ck);
        if (link) {
          const lk = keyOf(link.x, link.y);
          if (!obstacleSet.has(lk) && !visited.has(lk)) {
            visited.add(lk);
            q.push({x: link.x, y: link.y});
          }
        }

        for (const d of dirs4) {
          const nx = cur.x + d.x;
          const ny = cur.y + d.y;
          if (nx < 0 || nx >= tileX || ny < 0 || ny >= tileY) continue;
          const nk = keyOf(nx, ny);
          if (obstacleSet.has(nk) || visited.has(nk)) continue;
          visited.add(nk);
          q.push({x: nx, y: ny});
        }
      }

      const bKey = keyOf(startB.x, startB.y);
      if (!visited.has(bKey)) return false;

      const coverage = visited.size / freeCells;
      return coverage >= MAP_CFG.CONNECT_COVERAGE_MIN;
    }

    // ---------- clustered obstacles ----------
    function generateClusterCells({ seed, size, occ, forbidCenters = [], forbidRadius = 0 } = {}) {
      const cells = new Set();
      let cur = {x: seed.x, y: seed.y};

      const maxSteps = Math.max(10, size * MAP_CFG.CLUSTER_WALK_FACTOR);
      for (let i = 0; i < maxSteps && cells.size < size; i++) {
        const k = keyOf(cur.x, cur.y);
        if (isInsideMargin(cur.x, cur.y) &&
            !(forbidRadius > 0 && inSafeZone(cur.x, cur.y, forbidCenters, forbidRadius)) &&
            !occ.has(k)) {
          cells.add(k);
        }

        const d = dirs4[randInt(0, dirs4.length)];
        const nx = cur.x + d.x;
        const ny = cur.y + d.y;

        if (nx < 0 || nx >= tileX || ny < 0 || ny >= tileY) {
          if (cells.size > 0) {
            const any = Array.from(cells)[randInt(0, cells.size)];
            const [ax, ay] = any.split(',').map(Number);
            cur = {x: ax, y: ay};
          }
          continue;
        }
        cur = {x: nx, y: ny};
      }

      if (cells.size < size && cells.size > 0) {
        const arr = Array.from(cells).map(s => {
          const [x,y] = s.split(',').map(Number);
          return {x,y};
        });
        let guard = 0;
        while (cells.size < size && guard++ < 3000) {
          const base = arr[randInt(0, arr.length)];
          const d = dirs4[randInt(0, dirs4.length)];
          const nx = base.x + d.x;
          const ny = base.y + d.y;
          const nk = keyOf(nx, ny);
          if (!isInsideMargin(nx, ny)) continue;
          if (forbidRadius > 0 && inSafeZone(nx, ny, forbidCenters, forbidRadius)) continue;
          if (occ.has(nk) || cells.has(nk)) continue;
          cells.add(nk);
          arr.push({x:nx,y:ny});
        }
      }

      return Array.from(cells).map(s => {
        const [x,y] = s.split(',').map(Number);
        return {x,y};
      });
    }

    function tryBuildInitialMap() {
      obstacles = [];
      portals = [];
      foods = [];

      const spawnCenters = [
        { x: players[0].body[0].x, y: players[0].body[0].y },
        { x: players[1].body[0].x, y: players[1].body[0].y }
      ];

      let occ = buildOccupiedSet({ includeFoods: false });

      // portals
      for (let i = 0; i < MAP_CFG.PORTAL_PAIRS; i++) {
        const a = randomEmptyCell({
          occ,
          forbidCenters: spawnCenters,
          forbidRadius: MAP_CFG.SAFE_RADIUS_SPAWN
        });
        if (!a) break;
        occ.add(keyOf(a.x, a.y));

        let b = null;
        for (let t = 0; t < 2000; t++) {
          const cand = randomEmptyCell({
            occ,
            forbidCenters: spawnCenters,
            forbidRadius: MAP_CFG.SAFE_RADIUS_SPAWN,
            maxTry: 100
          });
          if (!cand) continue;
          const dist = Math.abs(cand.x - a.x) + Math.abs(cand.y - a.y);
          if (dist < 10) continue;
          b = cand;
          break;
        }
        if (!b) break;
        occ.add(keyOf(b.x, b.y));

        portals.push({
          a, b,
          color: i === 0 ? '#00ff00' : '#ffff00'
        });
      }

      // obstacles (clustered)
      const area = tileX * tileY;
      let target = Math.round(area * MAP_CFG.INITIAL_OBS_RATIO);
      target = Math.max(MAP_CFG.OBSTACLE_MIN, Math.min(MAP_CFG.OBSTACLE_MAX, target));
      target = Math.min(target, Math.max(0, area - occ.size - 10));

      while (obstacles.length < target) {
        const remain = target - obstacles.length;
        const size = Math.min(remain, randInt(MAP_CFG.CLUSTER_MIN_SIZE, MAP_CFG.CLUSTER_MAX_SIZE + 1));

        const seed = randomEmptyCell({
          occ,
          forbidCenters: spawnCenters,
          forbidRadius: MAP_CFG.SAFE_RADIUS_SPAWN
        });
        if (!seed) break;

        const clusterCells = generateClusterCells({
          seed,
          size,
          occ,
          forbidCenters: spawnCenters,
          forbidRadius: MAP_CFG.SAFE_RADIUS_SPAWN
        });

        for (const c of clusterCells) {
          const ck = keyOf(c.x, c.y);
          if (obstacles.length >= target) break;
          if (occ.has(ck)) continue;
          obstacles.push({x: c.x, y: c.y});
          occ.add(ck);
        }
      }

      const obstacleSet = new Set(obstacles.map(o => keyOf(o.x, o.y)));
      const ok = validateConnectivity({
        obstacleSet,
        startA: spawnCenters[0],
        startB: spawnCenters[1]
      });
      if (!ok) return false;

      for (let i = 0; i < MAP_CFG.INIT_FOOD_COUNT; i++) spawnFood();
      return true;
    }

    function createMapWithGuarantee() {
      for (let attempt = 0; attempt < MAP_CFG.MAX_GEN_ATTEMPTS; attempt++) {
        if (tryBuildInitialMap()) return;
      }

      // fallback
      obstacles = [];
      portals = [];
      foods = [];

      let occ = buildOccupiedSet({ includeFoods: false });
      const spawnCenters = [
        { x: players[0].body[0].x, y: players[0].body[0].y },
        { x: players[1].body[0].x, y: players[1].body[0].y }
      ];
      for (let i = 0; i < MAP_CFG.PORTAL_PAIRS; i++) {
        const a = randomEmptyCell({ occ, forbidCenters: spawnCenters, forbidRadius: MAP_CFG.SAFE_RADIUS_SPAWN });
        if (!a) break;
        occ.add(keyOf(a.x, a.y));
        const b = randomEmptyCell({ occ, forbidCenters: spawnCenters, forbidRadius: MAP_CFG.SAFE_RADIUS_SPAWN });
        if (!b) break;
        occ.add(keyOf(b.x, b.y));
        portals.push({ a, b, color: i === 0 ? '#00ff00' : '#ffff00' });
      }
      for (let i = 0; i < MAP_CFG.INIT_FOOD_COUNT; i++) spawnFood();
    }

    // ---------- dynamic difficulty ----------
    function totalScore() {
      return (players[0]?.score || 0) + (players[1]?.score || 0);
    }

    function maybeIncreaseDifficulty() {
      const level = Math.floor(totalScore() / MAP_CFG.SCORE_STEP);
      if (level <= difficultyLevel) return;

      while (difficultyLevel < level) {
        if (obstacles.length >= MAP_CFG.MAX_TOTAL_OBS) {
          difficultyLevel = level;
          return;
        }
        tryAddObstacleCluster();
        difficultyLevel++;
      }
    }

    function tryAddObstacleCluster() {
      const headCenters = [
        {x: players[0].body[0].x, y: players[0].body[0].y},
        {x: players[1].body[0].x, y: players[1].body[0].y}
      ];

      const occ = buildOccupiedSet({ includeFoods: true });
      const size = randInt(MAP_CFG.ADD_CLUSTER_MIN, MAP_CFG.ADD_CLUSTER_MAX + 1);

      for (let attempt = 0; attempt < 120; attempt++) {
        const seed = randomEmptyCell({
          occ,
          forbidCenters: headCenters,
          forbidRadius: MAP_CFG.SAFE_RADIUS_DYNAMIC,
          maxTry: 800
        });
        if (!seed) return false;

        const clusterCells = generateClusterCells({
          seed,
          size,
          occ,
          forbidCenters: headCenters,
          forbidRadius: MAP_CFG.SAFE_RADIUS_DYNAMIC
        });

        if (clusterCells.length === 0) continue;

        const obstacleSet = new Set(obstacles.map(o => keyOf(o.x, o.y)));
        for (const c of clusterCells) obstacleSet.add(keyOf(c.x, c.y));

        const ok = validateConnectivity({
          obstacleSet,
          startA: {x: players[0].body[0].x, y: players[0].body[0].y},
          startB: {x: players[1].body[0].x, y: players[1].body[0].y}
        });
        if (!ok) continue;

        for (const c of clusterCells) {
          if (obstacles.length >= MAP_CFG.MAX_TOTAL_OBS) break;
          const ck = keyOf(c.x, c.y);
          if (occ.has(ck)) continue;
          obstacles.push({x: c.x, y: c.y});
          occ.add(ck);
        }
        return true;
      }
      return false;
    }

    // ---------- food ----------
    function spawnFood() {
      const type = Math.random() > 0.8 ? 'gold' : 'normal';
      const occ = buildOccupiedSet({ includeFoods: true });

      const cell = randomEmptyCell({
        occ,
        forbidCenters: [],
        forbidRadius: 0,
        maxTry: 5000
      });
      if (!cell) return;

      foods.push({ ...cell, type });
    }

    // ---------- Snake ----------
    class Snake {
      constructor(id, color, startX, startY, startDir) {
        this.id = id;
        this.color = color;
        this.body = [
          {x: startX, y: startY},
          {x: startX, y: startY + 1},
          {x: startX, y: startY + 2}
        ];
        this.dir = startDir;
        this.nextDir = startDir;
        this.score = 0;
        this.dead = false;
      }

      update() {
        if (this.dead) return;

        this.dir = this.nextDir;
        let head = {x: this.body[0].x + this.dir.x, y: this.body[0].y + this.dir.y};

        // portals
        let ported = false;
        for (let p of portals) {
          if (head.x === p.a.x && head.y === p.a.y) {
            head = {x: p.b.x, y: p.b.y};
            ported = true;
          } else if (head.x === p.b.x && head.y === p.b.y) {
            head = {x: p.a.x, y: p.a.y};
            ported = true;
          }

          if (ported) {
            head.x += this.dir.x;
            head.y += this.dir.y;
            if (head.x < 0 || head.x >= tileX || head.y < 0 || head.y >= tileY) {
              this.dead = true;
              return;
            }
            break;
          }
        }

        // border
        if (!ported) {
          if (head.x < 0 || head.x >= tileX || head.y < 0 || head.y >= tileY) {
            this.dead = true;
            return;
          }
        }

        // obstacles
        for (let obs of obstacles) {
          if (head.x === obs.x && head.y === obs.y) {
            this.dead = true;
            return;
          }
        }

        // self collision
        for (let part of this.body) {
          if (head.x === part.x && head.y === part.y) {
            this.dead = true;
            return;
          }
        }

        // opponent collision（对手即使死了，尸体也算障碍）
        const opponent = players.find(p => p.id !== this.id);
        for (let part of opponent.body) {
          if (head.x === part.x && head.y === part.y) {
            this.dead = true;
            return;
          }
        }

        // 头对头：仅在双方都活着时才判定双死
        if (!opponent.dead) {
          const oppHead = opponent.body[0];
          if (head.x === oppHead.x && head.y === oppHead.y) {
            this.dead = true;
            opponent.dead = true;
            return;
          }
        }

        // move
        this.body.unshift(head);

        // eat
        let ate = false;
        for (let i = 0; i < foods.length; i++) {
          const f = foods[i];
          if (head.x === f.x && head.y === f.y) {
            this.score += (f.type === 'gold' ? 5 : 1);
            foods.splice(i, 1);
            spawnFood();
            ate = true;

            // 动态加障碍：吃到食物后触发
            maybeIncreaseDifficulty();
            break;
          }
        }

        if (!ate) this.body.pop();
      }
    }

    // ---------- input ----------
    document.addEventListener('keydown', e => {
      if (players.length < 2) return;
      const p1 = players[0];
      const p2 = players[1];

      // 死蛇不响应输入（可选，避免无意义）
      // if (p1.dead && (e.key.startsWith("Arrow"))) return;
      // if (p2.dead && ("wasdWASD".includes(e.key))) return;

      if (e.key === 'ArrowUp' && p1.dir.y !== 1) p1.nextDir = {x: 0, y: -1};
      if (e.key === 'ArrowDown' && p1.dir.y !== -1) p1.nextDir = {x: 0, y: 1};
      if (e.key === 'ArrowLeft' && p1.dir.x !== 1) p1.nextDir = {x: -1, y: 0};
      if (e.key === 'ArrowRight' && p1.dir.x !== -1) p1.nextDir = {x: 1, y: 0};

      if ((e.key === 'w' || e.key === 'W') && p2.dir.y !== 1) p2.nextDir = {x: 0, y: -1};
      if ((e.key === 's' || e.key === 'S') && p2.dir.y !== -1) p2.nextDir = {x: 0, y: 1};
      if ((e.key === 'a' || e.key === 'A') && p2.dir.x !== 1) p2.nextDir = {x: -1, y: 0};
      if ((e.key === 'd' || e.key === 'D') && p2.dir.x !== -1) p2.nextDir = {x: 1, y: 0};
    });

    // ---------- game control ----------
    function startGame() {
      resize();

      players = [
        new Snake(1, '#00ffff', tileX - 5, tileY - 5, {x: -1, y: 0}),
        new Snake(2, '#ff00ff', 5, 5, {x: 1, y: 0})
      ];

      foods = [];
      obstacles = [];
      portals = [];
      difficultyLevel = 0;

      createMapWithGuarantee();

      menuLayer.classList.add('hidden');
      winnerText.style.display = 'none';
      isRunning = true;

      if (gameInterval) clearInterval(gameInterval);
      gameInterval = setInterval(gameLoop, 1000 / 12);
    }

    function resetGame() {
      menuLayer.classList.remove('hidden');
      isRunning = false;
      clearInterval(gameInterval);
    }

    // 只有两条都死才结束：按分数判胜
    function gameOver() {
      isRunning = false;
      clearInterval(gameInterval);

      menuLayer.classList.remove('hidden');
      winnerText.style.display = 'block';

      const s1 = players[0].score;
      const s2 = players[1].score;

      if (s1 === s2) {
        winnerText.innerText = `DRAW! (SCORE ${s1}:${s2})`;
        winnerText.style.color = "#fff";
      } else if (s1 > s2) {
        winnerText.innerText = `PLAYER 1 WINS! (SCORE ${s1}:${s2})`;
        winnerText.style.color = "#00ffff";
      } else {
        winnerText.innerText = `PLAYER 2 WINS! (SCORE ${s1}:${s2})`;
        winnerText.style.color = "#ff00ff";
      }
    }

    function gameLoop() {
      players.forEach(p => p.update());

      // HUD：显示死亡状态
      p1ScoreEl.innerText = `P1 (Cyan): ${players[0].score}${players[0].dead ? " [DEAD]" : ""}`;
      p2ScoreEl.innerText = `P2 (Magenta): ${players[1].score}${players[1].dead ? " [DEAD]" : ""}`;

      // 关键：只有双死才结束
      if (players[0].dead && players[1].dead) {
        gameOver();
        return;
      }

      draw();
    }

    function draw() {
      ctx.fillStyle = '#050505';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // grid
      ctx.strokeStyle = 'rgba(255,255,255,0.02)';
      ctx.lineWidth = 1;
      for (let x = 0; x < canvas.width; x += gridSize) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,canvas.height); ctx.stroke(); }
      for (let y = 0; y < canvas.height; y += gridSize) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(canvas.width,y); ctx.stroke(); }

      // obstacles
      ctx.fillStyle = '#112244';
      ctx.shadowColor = '#0055ff';
      ctx.shadowBlur = 5;
      for (let o of obstacles) {
        ctx.fillRect(o.x * gridSize, o.y * gridSize, gridSize, gridSize);
      }
      ctx.shadowBlur = 0;

      // portals
      ctx.lineWidth = 2;
      for (let p of portals) {
        ctx.strokeStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = 15;

        ctx.beginPath();
        ctx.arc(p.a.x * gridSize + gridSize/2, p.a.y * gridSize + gridSize/2, gridSize/2, 0, Math.PI*2);
        ctx.stroke();
        ctx.fillStyle = p.color;
        ctx.font = '10px Arial';
        ctx.fillText("IN", p.a.x*gridSize, p.a.y*gridSize);

        ctx.beginPath();
        ctx.arc(p.b.x * gridSize + gridSize/2, p.b.y * gridSize + gridSize/2, gridSize/2, 0, Math.PI*2);
        ctx.stroke();
        ctx.fillText("OUT", p.b.x*gridSize, p.b.y*gridSize);
      }
      ctx.shadowBlur = 0;

      // foods
      for (let f of foods) {
        if (f.type === 'gold') {
          ctx.fillStyle = '#ffd700';
          ctx.shadowColor = '#ffd700';
          ctx.shadowBlur = 15;
        } else {
          ctx.fillStyle = '#ff3333';
          ctx.shadowColor = '#ff3333';
          ctx.shadowBlur = 10;
        }
        ctx.beginPath();
        ctx.arc(f.x * gridSize + gridSize/2, f.y * gridSize + gridSize/2, gridSize/3, 0, Math.PI*2);
        ctx.fill();
      }
      ctx.shadowBlur = 0;

      // snakes（死蛇画暗一点：降低shadow）
      players.forEach(p => {
        ctx.fillStyle = p.color;
        ctx.shadowColor = p.color;
        ctx.shadowBlur = p.dead ? 2 : 10;

        for (let part of p.body) {
          ctx.fillRect(part.x * gridSize + 1, part.y * gridSize + 1, gridSize - 2, gridSize - 2);
        }
      });
      ctx.shadowBlur = 0;
    }

    // init
    resize();
    ctx.fillStyle = '#050505';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  </script>
</body>
</html>
